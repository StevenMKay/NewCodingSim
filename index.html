<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Smooth Code Typer with Live Preview</title>
  <style>
    body {
      margin: 0;
      font-family: monospace;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding: 10px;
      box-sizing: border-box;
    }

    #livePreview {
      position: relative;
      width: 100%;
      height: 500px;
      border: none;
      background: white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      margin-bottom: 10px;
      border-radius: 18px;
    }

    #codeBox {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      white-space: pre-wrap;
      overflow-y: auto;
      border-bottom: 2px solid #ccc;
      height: 300px;
      margin: 0;
      scroll-behavior: smooth;
      border-radius: 18px;
      font-size: 17px;
      line-height: 1.4;
      /* Hide scrollbar but keep functionality */
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    #codeBox::-webkit-scrollbar {
      display: none;
    }

    .cursor {
      display: inline-block;
      width: 8px;
      background: #d4d4d4;
      animation: blink 1s steps(1) infinite;
      vertical-align: bottom;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      50.01%, 100% { opacity: 0; }
    }

    #inputArea {
      background: rgba(255,255,255,0.18);
      border-radius: 18px;
      box-shadow: 0 2px 18px rgba(0,0,0,0.13);
      padding: 28px 28px 18px 28px;
      margin-top: 10px;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: white;
      transition: box-shadow 0.2s;
    }

    #inputArea label {
      color: white;
      font-weight: bold;
    }

    #inputArea.hidden {
      display: none;
    }

    textarea {
      width: 100%;
      height: 120px;
      font-family: monospace;
      padding: 10px;
      font-size: 12px;
      resize: vertical;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 12px;
      box-sizing: border-box;
      background: rgba(255,255,255,0.9);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    button {
      margin-top: 10px;
      padding: 12px 20px;
      font-size: 14px;
      cursor: pointer;
      background: rgba(255,255,255,0.18);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      color: white;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 18px;
      width: 100%;
      box-shadow: 0 2px 18px rgba(0,0,0,0.13);
      transition: box-shadow 0.2s, transform 0.2s;
      font-weight: bold;
    }

    button:hover {
      box-shadow: 0 4px 24px rgba(0,0,0,0.18);
      transform: translateY(-1px);
    }

    /* Mobile optimizations */
    @media (max-width: 480px) {
      body {
        padding: 5px;
      }
      
      #livePreview {
        height: 65vh;
        border-radius: 12px;
      }
      
      #codeBox {
        height: 20vh;
        font-size: 24px;
        padding: 10px;
        border-radius: 12px;
      }
      
      #inputArea {
        padding: 20px;
        border-radius: 12px;
      }
      
      textarea {
        height: 100px;
        font-size: 11px;
        border-radius: 8px;
      }
      
      button {
        padding: 15px;
        font-size: 16px;
        border-radius: 12px;
      }
    }
  </style>
</head>
<body>

  <iframe id="livePreview"></iframe>
  <div id="codeBox"></div>

  <div id="inputArea">
    <label for="userCode"><strong>Paste your HTML/CSS/JS code below:</strong></label>
    <textarea id="userCode" placeholder="Paste your code here..."></textarea>
    <button id="startBtn">Start Typing</button>
  </div>

  <script>
    const startBtn = document.getElementById("startBtn");
    const userCode = document.getElementById("userCode");
    const codeBox = document.getElementById("codeBox");
    const livePreview = document.getElementById("livePreview");

    startBtn.addEventListener("click", () => {
      console.log("Button clicked - starting typing");
      const fullCode = userCode.value;
      if (!fullCode) return;

      document.getElementById("inputArea").classList.add("hidden");

      codeBox.innerHTML = "";
      codeBox.scrollTop = 0;
      let i = 0;
      let currentCode = "";

      const iframeDoc = livePreview.contentDocument || livePreview.contentWindow.document;
      iframeDoc.open();
      iframeDoc.write(`<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body></body></html>`);
      iframeDoc.close();

      // Check if it's a complete HTML document or just a fragment
      const isCompleteDocument = fullCode.includes('<!DOCTYPE html>') || 
                                (fullCode.includes('<html') && fullCode.includes('<body'));

      // PRE-ANALYZE CSS and categorize into stages
      let finalHtml = '';
      let finalCss = '';
      let stage1Css = ''; // Basic layout (display, position, width, height, margin, padding, flex)
      let stage2Css = ''; // Colors/effects (background, color, border, box-shadow, text-shadow)
      let stage3Css = ''; // Animations/hover (transition, transform, animation, hover states)

      if (isCompleteDocument) {
        const bodyMatch = fullCode.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        const styleMatch = fullCode.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
        finalHtml = bodyMatch ? bodyMatch[1] : '';
        finalCss = styleMatch ? styleMatch[1] : '';
      } else {
        const htmlContent = fullCode.match(/^[\s\S]*?(?=<style|$)/);
        const styleContent = fullCode.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
        finalHtml = htmlContent ? htmlContent[0].replace(/<style[\s\S]*?<\/style>/i, '').trim() : '';
        finalCss = styleContent ? styleContent[1] : '';
      }

      // Categorize CSS properties into stages
      function categorizeCSS(cssText) {
        const stage1Props = ['display', 'position', 'top', 'left', 'right', 'bottom', 'width', 'height', 'max-width', 'min-width', 'max-height', 'min-height', 'margin', 'padding', 'flex', 'flex-direction', 'justify-content', 'align-items', 'grid', 'float', 'clear', 'overflow', 'z-index'];
        const stage2Props = ['background', 'background-color', 'background-image', 'background-size', 'background-position', 'color', 'border', 'border-radius', 'box-shadow', 'text-shadow', 'font-size', 'font-family', 'font-weight', 'text-align', 'opacity'];
        const stage3Props = ['transition', 'transform', 'animation', ':hover', ':before', ':after', 'cursor'];

        let stage1 = '';
        let stage2 = '';
        let stage3 = '';

        // Parse CSS rules
        const rules = cssText.match(/[^{}]+\{[^{}]*\}/g) || [];
        
        rules.forEach(rule => {
          const selectorMatch = rule.match(/([^{]+)\{([^}]*)\}/);
          if (selectorMatch) {
            const selector = selectorMatch[1].trim();
            const properties = selectorMatch[2];
            
            // Check if it's a hover or pseudo-element (stage 3)
            if (selector.includes(':hover') || selector.includes(':before') || selector.includes(':after')) {
              stage3 += rule + '\n';
              return;
            }

            // Categorize properties within this rule
            let stage1PropsForRule = [];
            let stage2PropsForRule = [];
            let stage3PropsForRule = [];

            const propDeclarations = properties.split(';').filter(p => p.trim());
            propDeclarations.forEach(prop => {
              const propName = prop.split(':')[0].trim();
              const found1 = stage1Props.some(p => propName.startsWith(p));
              const found3 = stage3Props.some(p => propName.startsWith(p));
              
              if (found1) {
                stage1PropsForRule.push(prop.trim());
              } else if (found3) {
                stage3PropsForRule.push(prop.trim());
              } else {
                stage2PropsForRule.push(prop.trim());
              }
            });

            // Create separate rules for each stage
            if (stage1PropsForRule.length > 0) {
              stage1 += `${selector} { ${stage1PropsForRule.join('; ')}; }\n`;
            }
            if (stage2PropsForRule.length > 0) {
              stage2 += `${selector} { ${stage2PropsForRule.join('; ')}; }\n`;
            }
            if (stage3PropsForRule.length > 0) {
              stage3 += `${selector} { ${stage3PropsForRule.join('; ')}; }\n`;
            }
          }
        });

        return { stage1, stage2, stage3 };
      }

      const cssStages = categorizeCSS(finalCss);
      stage1Css = cssStages.stage1;
      stage2Css = cssStages.stage2;
      stage3Css = cssStages.stage3;

      // Create style elements for each stage
      const stage1Style = iframeDoc.createElement('style');
      stage1Style.id = 'stage1-layout';
      iframeDoc.head.appendChild(stage1Style);

      const stage2Style = iframeDoc.createElement('style');
      stage2Style.id = 'stage2-colors';
      iframeDoc.head.appendChild(stage2Style);

      const stage3Style = iframeDoc.createElement('style');
      stage3Style.id = 'stage3-effects';
      iframeDoc.head.appendChild(stage3Style);

      // Pre-load HTML (Stage 1: Reveal HTML structure)
      if (finalHtml) {
        iframeDoc.body.innerHTML = finalHtml;
        
        // NEW: Hide all elements initially
        const allElements = iframeDoc.body.querySelectorAll('*');
        allElements.forEach(el => {
          el.style.opacity = '0';
          el.style.transition = 'opacity 0.5s ease';
        });
        console.log(`Hidden ${allElements.length} elements initially`);
      }

      let htmlRevealed = false;
      let layoutApplied = false;
      let colorsApplied = false;
      let effectsApplied = false;
      let elementRevealIndex = 0; // NEW: Track which element to reveal next

      function updatePreview(justTypedChar) {
        // NEW: Reveal next element when > is typed
        if (justTypedChar === '>') {
          const allElements = iframeDoc.body.querySelectorAll('*');
          if (elementRevealIndex < allElements.length) {
            const elementToReveal = allElements[elementRevealIndex];
            elementToReveal.style.opacity = '1';
            console.log(`Revealed element ${elementRevealIndex + 1}: ${elementToReveal.tagName}`);
            elementRevealIndex++;
          }
        }

        // NEW: Apply CSS stages when } is typed
        if (justTypedChar === '}') {
          console.log('CSS rule completed with }');
          const progress = currentCode.length / fullCode.length;

          // Apply CSS stages progressively based on } characters
          if (!layoutApplied) {
            layoutApplied = true;
            stage1Style.textContent = stage1Css;
            console.log('Stage 2: Basic Layout Applied');
          } else if (!colorsApplied) {
            colorsApplied = true;
            stage2Style.textContent = stage2Css;
            console.log('Stage 3: Colors/Effects Applied');
          } else if (!effectsApplied) {
            effectsApplied = true;
            stage3Style.textContent = stage3Css;
            console.log('Stage 4: Animations/Hover Effects Applied');
          }
        }

        // Ensure HTML structure is revealed when first > appears
        if (justTypedChar === '>' && !htmlRevealed) {
          htmlRevealed = true;
          console.log('Stage 1: HTML Structure Revealed');
        }

        // Handle JavaScript execution
        const scriptMatches = currentCode.match(/<script[^>]*>([\s\S]*?)<\/script>/gi);
        if (scriptMatches) {
          const existingScripts = iframeDoc.querySelectorAll('script[data-typed="true"]');
          existingScripts.forEach(script => script.remove());
          
          scriptMatches.forEach(scriptTag => {
            const content = scriptTag.match(/<script[^>]*>([\s\S]*?)<\/script>/i);
            if (content && content[1]) {
              const newScript = iframeDoc.createElement('script');
              newScript.setAttribute('data-typed', 'true');
              newScript.textContent = content[1];
              iframeDoc.body.appendChild(newScript);
            }
          });
        }
      }

      function typeNextChar() {
        if (i < fullCode.length) {
          const char = fullCode[i] || '';
          currentCode += char;
          i++;

          let displayText = currentCode
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/ /g, "&nbsp;")
            .replace(/\n/g, "<br>");
          codeBox.innerHTML = displayText;
          const cursor = document.createElement('span');
          cursor.className = 'cursor';
          cursor.textContent = '|';
          codeBox.appendChild(cursor);

          setTimeout(() => {
            codeBox.scrollTop = codeBox.scrollHeight;
          }, 0);

          // Update preview - pass the character that was just typed
          updatePreview(char);

          setTimeout(typeNextChar, 1);
        } else {
          // Typing complete - ensure all stages are applied
          if (!htmlRevealed) {
            console.log('Final: HTML Structure Revealed');
          }
          if (!layoutApplied) {
            stage1Style.textContent = stage1Css;
            console.log('Final: Basic Layout Applied');
          }
          if (!colorsApplied) {
            stage2Style.textContent = stage2Css;
            console.log('Final: Colors/Effects Applied');
          }
          if (!effectsApplied) {
            stage3Style.textContent = stage3Css;
            console.log('Final: Animations/Hover Effects Applied');
          }
        }
      }

      typeNextChar();
    });
  </script>

</body>
</html>
