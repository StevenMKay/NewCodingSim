<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>True Gravitational Lensing Button</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .lens-button {
            position: absolute;
            z-index: 100;
            padding: 30px 50px;
            font-size: 28px;
            font-weight: bold;
            color: #ffffff;
            background: rgba(255, 107, 53, 0.2);
            border: 1px solid rgba(255, 170, 68, 0.3);
            border-radius: 60px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            box-shadow: 
                0 10px 30px rgba(255, 107, 53, 0.3),
                inset 0 2px 10px rgba(255, 255, 255, 0.1);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 
                0 0 10px rgba(255, 170, 68, 0.6),
                0 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 2px;
            transform-origin: center;
            overflow: visible;
        }

        .lens-button.lensing {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #ffffff;
            text-shadow: 
                0 0 15px rgba(255, 170, 68, 1),
                0 0 30px rgba(255, 107, 53, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.3);
            box-shadow: 
                0 15px 40px rgba(255, 107, 53, 0.4),
                0 0 60px rgba(255, 170, 68, 0.2),
                inset 0 2px 10px rgba(255, 255, 255, 0.2);
        }

        .button-text {
            display: inline-block;
            transition: all 0.1s ease-out;
        }

        .button-text .letter {
            display: inline-block;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center;
        }

        .lens-button:hover {
            transform: translateY(-3px);
        }

        #starCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #lensCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            pointer-events: none;
        }

        .info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="starCanvas"></canvas>
        <canvas id="lensCanvas"></canvas>
        <button class="lens-button" id="lensButton">
            <span class="button-text" id="buttonText">ACTIVATE</span>
        </button>
    </div>
    


    <script>
        const starCanvas = document.getElementById('starCanvas');
        const lensCanvas = document.getElementById('lensCanvas');
        const starCtx = starCanvas.getContext('2d');
        const lensCtx = lensCanvas.getContext('2d');
        const button = document.getElementById('lensButton');
        const buttonText = document.getElementById('buttonText');

        let stars = [];
        let originalStars = [];
        let lightParticles = [];
        let originalParticles = [];
        let mouseX = 0;
        let mouseY = 0;
        let isLensing = false;
        let lensStrength = 0;
        let targetLensStrength = 0;
        let buttonOriginalRect = null;
        let letters = [];

        function resizeCanvases() {
            starCanvas.width = window.innerWidth;
            starCanvas.height = window.innerHeight;
            lensCanvas.width = window.innerWidth;
            lensCanvas.height = window.innerHeight;
            
            // Store original button position for distortion calculations
            const buttonRect = button.getBoundingClientRect();
            buttonOriginalRect = {
                x: buttonRect.left + buttonRect.width / 2,
                y: buttonRect.top + buttonRect.height / 2,
                width: buttonRect.width,
                height: buttonRect.height
            };
            
            if (stars.length === 0) {
                generateStarfield();
            }
        }

        function initializeTextDistortion() {
            // Break text into individual letters for gravitational distortion
            const text = buttonText.textContent;
            buttonText.innerHTML = '';
            letters = [];
            
            for (let i = 0; i < text.length; i++) {
                const letter = document.createElement('span');
                letter.className = 'letter';
                letter.textContent = text[i];
                letter.style.position = 'relative';
                buttonText.appendChild(letter);
                
                letters.push({
                    element: letter,
                    originalX: 0,
                    originalY: 0,
                    index: i
                });
            }
        }

        function generateStarfield() {
            stars = [];
            originalStars = [];
            const numStars = 2000;
            
            for (let i = 0; i < numStars; i++) {
                const star = {
                    x: Math.random() * starCanvas.width,
                    y: Math.random() * starCanvas.height,
                    size: Math.random() * 2 + 0.5,
                    brightness: Math.random() * 0.8 + 0.2,
                    color: getStarColor(),
                    twinkle: Math.random() * Math.PI * 2,
                    twinkleSpeed: Math.random() * 0.02 + 0.01
                };
                stars.push({...star});
                originalStars.push({...star});
            }

            // Generate 3D light particles around button (like Galaxy.html particle system)
            lightParticles = [];
            originalParticles = [];
            const numParticles = 800;
            const centerX = starCanvas.width / 2;
            const centerY = starCanvas.height / 2;
            
            for (let i = 0; i < numParticles; i++) {
                // Create particles in 3D space around the button
                const distance = 80 + Math.random() * 300;
                const angle = Math.random() * Math.PI * 2;
                const verticalAngle = (Math.random() - 0.5) * Math.PI * 0.6; // 3D depth
                
                const particle = {
                    x: centerX + Math.cos(angle) * distance,
                    y: centerY + Math.sin(angle) * distance * Math.cos(verticalAngle),
                    z: Math.sin(verticalAngle) * distance * 0.5, // 3D depth component
                    originalX: centerX + Math.cos(angle) * distance,
                    originalY: centerY + Math.sin(angle) * distance * Math.cos(verticalAngle),
                    originalZ: Math.sin(verticalAngle) * distance * 0.5,
                    velocity: {
                        x: Math.cos(angle + Math.PI/2) * 0.5,
                        y: Math.sin(angle + Math.PI/2) * 0.5 * Math.cos(verticalAngle),
                        z: 0
                    },
                    size: Math.random() * 1.5 + 0.8,
                    brightness: Math.random() * 0.7 + 0.3,
                    color: Math.random() < 0.7 ? [255, 170, 68] : [255, 107, 53],
                    life: Math.random() * 100 + 50,
                    maxLife: Math.random() * 100 + 50,
                    angle: angle,
                    distance: distance
                };
                
                lightParticles.push({...particle});
                originalParticles.push({...particle});
            }
        }

        function getStarColor() {
            const colors = [
                '#ffffff', '#ffffcc', '#ffccaa', '#aaccff', 
                '#ccaaff', '#ffaacc', '#aaffcc', '#ffcc99'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Real gravitational lensing physics + smooth text distortion transitions
        function applyGravitationalLensing() {
            const lensX = mouseX || window.innerWidth / 2;
            const lensY = mouseY || window.innerHeight / 2;
            const schwarzschildRadius = 120 * lensStrength;
            const lensingRadius = 500 * lensStrength;

            // Apply gravitational effects to light particles (like Galaxy.html)
            for (let i = 0; i < lightParticles.length; i++) {
                const particle = lightParticles[i];
                const originalParticle = originalParticles[i];
                
                if (lensStrength === 0) {
                    // Smoothly return to original positions
                    particle.x = originalParticle.originalX;
                    particle.y = originalParticle.originalY;
                    particle.z = originalParticle.originalZ;
                    particle.size = originalParticle.size;
                    particle.brightness = originalParticle.brightness;
                    continue;
                }

                const dx = originalParticle.originalX - lensX;
                const dy = originalParticle.originalY - lensY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < lensingRadius && distance > 0) {
                    // Real gravitational lensing calculations (from Galaxy.html physics)
                    const lensEffect = schwarzschildRadius / (distance + 10);
                    const bendFactor = Math.min(lensEffect * 1.2, 3.0);
                    
                    const angle = Math.atan2(dy, dx);
                    
                    // Light bending around massive object
                    const deflectionAngle = bendFactor * 0.15;
                    const bentAngle = angle + deflectionAngle;
                    
                    // Apply frame-dragging effect (spacetime rotation)
                    const frameDragging = (schwarzschildRadius / distance) * 0.02;
                    const draggedAngle = bentAngle + frameDragging;
                    
                    // Calculate new position with gravitational effects
                    if (distance < schwarzschildRadius * 1.5) {
                        // Near event horizon - extreme effects
                        const escapeRadius = schwarzschildRadius * 2.5;
                        particle.x = lensX + Math.cos(draggedAngle) * escapeRadius;
                        particle.y = lensY + Math.sin(draggedAngle) * escapeRadius;
                        particle.z = originalParticle.originalZ * (1 + bendFactor * 0.3); // 3D distortion
                        
                        // Redshift effect - particles get dimmer and redder near black hole
                        particle.brightness = originalParticle.brightness * (2 + bendFactor);
                        particle.size = originalParticle.size * (1.5 + bendFactor * 0.5);
                        
                        // Gravitational redshift
                        const redshiftFactor = 1 - (schwarzschildRadius / (distance + 20));
                        particle.color = [
                            255 * redshiftFactor + 200 * (1 - redshiftFactor),
                            (170 * redshiftFactor + 80 * (1 - redshiftFactor)),
                            (68 * redshiftFactor + 20 * (1 - redshiftFactor))
                        ];
                    } else {
                        // Normal gravitational lensing
                        const newDistance = distance + bendFactor * 25;
                        particle.x = lensX + Math.cos(bentAngle) * newDistance;
                        particle.y = lensY + Math.sin(bentAngle) * newDistance;
                        particle.z = originalParticle.originalZ + Math.sin(bentAngle * 2) * bendFactor * 10;
                        
                        // Gravitational magnification
                        const magnification = 1 + (schwarzschildRadius / distance) * 0.8;
                        particle.brightness = originalParticle.brightness * magnification;
                        particle.size = originalParticle.size * Math.min(magnification, 2);
                        
                        // Maintain original color for distant particles
                        particle.color = originalParticle.color;
                    }
                } else {
                    // Particles outside lensing area
                    particle.x = originalParticle.originalX;
                    particle.y = originalParticle.originalY;
                    particle.z = originalParticle.originalZ;
                    particle.size = originalParticle.size;
                    particle.brightness = originalParticle.brightness;
                    particle.color = originalParticle.color;
                }
            }

            // Apply smooth text distortion with gravitational effects
            if (buttonOriginalRect && letters.length > 0) {
                letters.forEach((letter, index) => {
                    const letterRect = letter.element.getBoundingClientRect();
                    const letterCenterX = letterRect.left + letterRect.width / 2;
                    const letterCenterY = letterRect.top + letterRect.height / 2;
                    
                    const dx = letterCenterX - lensX;
                    const dy = letterCenterY - lensY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    let targetTransform = '';
                    
                    if (distance < lensingRadius && distance > 0 && lensStrength > 0) {
                        const distortionFactor = (schwarzschildRadius / (distance + 20)) * lensStrength;
                        
                        // Individual letter gravitational effects
                        const scaleX = 1 + distortionFactor * 0.4;
                        const scaleY = 1 + distortionFactor * 0.6;
                        const skewX = distortionFactor * Math.sin(dx * 0.02) * 20;
                        const skewY = distortionFactor * Math.cos(dy * 0.02) * 15;
                        const rotateZ = distortionFactor * Math.sin(distance * 0.03 + index) * 25;
                        
                        // Displacement due to gravitational bending
                        const angle = Math.atan2(dy, dx);
                        const bendStrength = distortionFactor * 8;
                        const translateX = Math.cos(angle + Math.PI/2) * bendStrength;
                        const translateY = Math.sin(angle + Math.PI/2) * bendStrength;
                        
                        targetTransform = `
                            translateX(${translateX}px)
                            translateY(${translateY}px)
                            scaleX(${scaleX})
                            scaleY(${scaleY})
                            skewX(${skewX}deg)
                            skewY(${skewY}deg)
                            rotateZ(${rotateZ}deg)
                        `;
                    }
                    
                    // Apply transform with smooth transition
                    letter.element.style.transform = targetTransform;
                });
            }

            // Apply lensing to background stars
            for (let i = 0; i < stars.length; i++) {
                if (lensStrength === 0) {
                    stars[i].x = originalStars[i].x;
                    stars[i].y = originalStars[i].y;
                    stars[i].size = originalStars[i].size;
                    stars[i].brightness = originalStars[i].brightness;
                    continue;
                }

                const originalStar = originalStars[i];
                const dx = originalStar.x - lensX;
                const dy = originalStar.y - lensY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < lensingRadius && distance > 0) {
                    const lensEffect = schwarzschildRadius / distance;
                    const bendFactor = Math.min(lensEffect * 0.5, 2.0);
                    
                    const angle = Math.atan2(dy, dx);
                    const bentAngle = angle + bendFactor * 0.1;
                    
                    if (distance < schwarzschildRadius * 2) {
                        // Einstein ring effect
                        const ringRadius = schwarzschildRadius * 1.8;
                        stars[i].x = lensX + Math.cos(angle) * ringRadius;
                        stars[i].y = lensY + Math.sin(angle) * ringRadius;
                        stars[i].brightness = originalStar.brightness * 2.5;
                        stars[i].size = originalStar.size * 1.8;
                    } else {
                        // Normal gravitational bending
                        const newDistance = distance + bendFactor * 30;
                        stars[i].x = lensX + Math.cos(bentAngle) * newDistance;
                        stars[i].y = lensY + Math.sin(bentAngle) * newDistance;
                        
                        const magnification = 1 + (schwarzschildRadius / distance) * 0.6;
                        stars[i].brightness = originalStar.brightness * magnification;
                        stars[i].size = originalStar.size * Math.min(magnification, 2);
                    }
                } else {
                    stars[i].x = originalStar.x;
                    stars[i].y = originalStar.y;
                    stars[i].size = originalStar.size;
                    stars[i].brightness = originalStar.brightness;
                }
            }
        }

        function drawStarfield() {
            starCtx.fillStyle = '#000';
            starCtx.fillRect(0, 0, starCanvas.width, starCanvas.height);

            const time = Date.now() * 0.001;

            // Draw background stars
            for (let star of stars) {
                const twinkle = Math.sin(time * star.twinkleSpeed + star.twinkle) * 0.3 + 0.7;
                const alpha = star.brightness * twinkle;
                
                starCtx.fillStyle = star.color;
                starCtx.globalAlpha = alpha;
                
                starCtx.beginPath();
                starCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                starCtx.fill();
                
                // Add star glow for bright stars
                if (star.brightness > 1.2) {
                    const glowSize = star.size * 3;
                    const glowGradient = starCtx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, glowSize
                    );
                    glowGradient.addColorStop(0, star.color + '40');
                    glowGradient.addColorStop(1, star.color + '00');
                    
                    starCtx.fillStyle = glowGradient;
                    starCtx.beginPath();
                    starCtx.arc(star.x, star.y, glowSize, 0, Math.PI * 2);
                    starCtx.fill();
                }
            }

            // Draw 3D light particles (like Galaxy.html particle system)
            for (let particle of lightParticles) {
                // 3D perspective calculation
                const perspective = 300;
                const scale = perspective / (perspective + particle.z);
                const projectedX = particle.x;
                const projectedY = particle.y;
                const projectedSize = particle.size * scale;

                // Skip particles that are too far back
                if (scale < 0.1) continue;

                // Color with 3D depth shading
                const [r, g, b] = Array.isArray(particle.color) ? particle.color : [255, 170, 68];
                const depthShading = Math.max(0.3, scale);
                const finalR = Math.floor(r * depthShading);
                const finalG = Math.floor(g * depthShading);
                const finalB = Math.floor(b * depthShading);

                const alpha = particle.brightness * scale;
                
                // Draw particle core
                starCtx.fillStyle = `rgba(${finalR}, ${finalG}, ${finalB}, ${alpha})`;
                starCtx.beginPath();
                starCtx.arc(projectedX, projectedY, projectedSize, 0, Math.PI * 2);
                starCtx.fill();

                // Add particle glow (more intense for closer particles)
                if (projectedSize > 0.8) {
                    const glowSize = projectedSize * 4;
                    const glowGradient = starCtx.createRadialGradient(
                        projectedX, projectedY, 0,
                        projectedX, projectedY, glowSize
                    );
                    glowGradient.addColorStop(0, `rgba(${finalR}, ${finalG}, ${finalB}, ${alpha * 0.6})`);
                    glowGradient.addColorStop(0.5, `rgba(${finalR}, ${finalG}, ${finalB}, ${alpha * 0.2})`);
                    glowGradient.addColorStop(1, `rgba(${finalR}, ${finalG}, ${finalB}, 0)`);
                    
                    starCtx.fillStyle = glowGradient;
                    starCtx.beginPath();
                    starCtx.arc(projectedX, projectedY, glowSize, 0, Math.PI * 2);
                    starCtx.fill();

                    // Add bright core for very close particles
                    if (scale > 0.8) {
                        starCtx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.4})`;
                        starCtx.beginPath();
                        starCtx.arc(projectedX, projectedY, projectedSize * 0.3, 0, Math.PI * 2);
                        starCtx.fill();
                    }
                }
            }
            
            starCtx.globalAlpha = 1;
        }

        function drawLensingVisualization() {
            lensCtx.clearRect(0, 0, lensCanvas.width, lensCanvas.height);
            
            const centerX = mouseX || window.innerWidth / 2;
            const centerY = mouseY || window.innerHeight / 2;

            // Only draw effects if there's some lensing strength
            if (lensStrength > 0.01) {
                // Event horizon glow (always subtle)
                const horizonRadius = 120 * lensStrength;
                const horizonGradient = lensCtx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, horizonRadius
                );
                
                horizonGradient.addColorStop(0, `rgba(255, 170, 68, ${0.3 * lensStrength})`);
                horizonGradient.addColorStop(0.5, `rgba(255, 107, 53, ${0.15 * lensStrength})`);
                horizonGradient.addColorStop(1, 'rgba(255, 170, 68, 0)');
                
                lensCtx.fillStyle = horizonGradient;
                lensCtx.beginPath();
                lensCtx.arc(centerX, centerY, horizonRadius, 0, Math.PI * 2);
                lensCtx.fill();

                // Gravitational field rings (subtle, only when strong lensing)
                if (lensStrength > 0.5) {
                    const maxRadius = 400 * lensStrength;
                    for (let i = 1; i <= 4; i++) {
                        const radius = (maxRadius / 4) * i;
                        const opacity = (1 - i / 4) * 0.08 * lensStrength;
                        
                        lensCtx.beginPath();
                        lensCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        lensCtx.strokeStyle = `rgba(255, 170, 68, ${opacity})`;
                        lensCtx.lineWidth = 1;
                        lensCtx.stroke();
                    }
                }
            }
        }

        // Event listeners
        button.addEventListener('mouseenter', (e) => {
            isLensing = true;
            targetLensStrength = 1.0;
            button.classList.add('lensing');
            const rect = starCanvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        button.addEventListener('mouseleave', () => {
            isLensing = false;
            targetLensStrength = 0.0;
            button.classList.remove('lensing');
        });

        button.addEventListener('mousemove', (e) => {
            if (isLensing) {
                const rect = starCanvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
            }
        });

        // Add click effect with gravitational pulse
        button.addEventListener('click', () => {
            // Create a gravitational wave pulse effect
            const pulseElement = document.createElement('div');
            pulseElement.style.cssText = `
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 10px;
                height: 10px;
                border: 2px solid rgba(255, 170, 68, 0.8);
                border-radius: 50%;
                pointer-events: none;
                z-index: 1000;
                animation: gravitationalPulse 1s ease-out forwards;
            `;
            
            button.parentNode.appendChild(pulseElement);
            
            // Remove element after animation
            setTimeout(() => {
                if (pulseElement.parentNode) {
                    pulseElement.parentNode.removeChild(pulseElement);
                }
            }, 1000);
        });

        // Add gravitational pulse animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes gravitationalPulse {
                0% {
                    width: 10px;
                    height: 10px;
                    opacity: 1;
                    border-width: 2px;
                }
                100% {
                    width: 600px;
                    height: 600px;
                    opacity: 0;
                    border-width: 1px;
                }
            }
        `;
        document.head.appendChild(style);

        function animate() {
            // Smooth lens strength transition (SMOOTH gravitational fade in/out)
            const transitionSpeed = 0.04;
            if (Math.abs(lensStrength - targetLensStrength) > 0.001) {
                if (lensStrength < targetLensStrength) {
                    lensStrength += transitionSpeed;
                    if (lensStrength > targetLensStrength) lensStrength = targetLensStrength;
                } else {
                    lensStrength -= transitionSpeed;
                    if (lensStrength < targetLensStrength) lensStrength = targetLensStrength;
                }
            }

            applyGravitationalLensing();
            drawStarfield();
            drawLensingVisualization();
            
            requestAnimationFrame(animate);
        }

        // Initialize
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
        initializeTextDistortion();
        animate();
    </script>
</body>
</html>
