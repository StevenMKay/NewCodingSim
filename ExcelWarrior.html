<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Warrior: Formula Fighter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1e3a1e;
            display: flex;
            justify-content: center;
            align-items: top;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 900px;
            border: 3px solid #217346;
            box-shadow: 
                0 0 30px rgba(33, 115, 70, 0.6),
                inset 0 0 20px rgba(33, 115, 70, 0.1);
            background: linear-gradient(180deg, #0e2818 0%, #0a1a0e 70%, #071009 100%);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: transparent;
            border: none;
            height: 900px;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            color: #217346;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            text-shadow: 0 0 5px rgba(33, 115, 70, 0.8);
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #217346;
            z-index: 20;
        }

        .title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(33, 115, 70, 0.8);
            animation: pulse 2s infinite;
            background: linear-gradient(45deg, #217346, #70ad47, #a9d18e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 18px;
            margin-bottom: 30px;
            opacity: 0.8;
            text-align: center;
            line-height: 1.4;
        }

        .controls {
            font-size: 14px;
            text-align: center;
            line-height: 1.6;
            opacity: 0.7;
        }

        .excel-logo {
            font-size: 64px;
            margin-bottom: 20px;
            animation: logoSpin 3s ease-in-out infinite alternate;
        }

        @keyframes logoSpin {
            0% { transform: rotate(-5deg) scale(1); }
            100% { transform: rotate(5deg) scale(1.1); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(20px); }
            20% { opacity: 0.7; transform: translateY(0); }
            80% { opacity: 0.7; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        #gameOverScreen, #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ff4444;
            z-index: 20;
        }

        #victoryScreen {
            background: linear-gradient(45deg, rgba(0, 0, 0, 0.85), rgba(14, 40, 24, 0.8));
            backdrop-filter: blur(8px);
            color: #217346;
            z-index: 30;
        }

        .victory-title {
            font-size: 52px;
            font-weight: bold;
            margin-bottom: 25px;
            background: linear-gradient(45deg, #217346, #70ad47, #a9d18e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(33, 115, 70, 0.5);
            animation: victoryPulse 3s infinite;
        }

        @keyframes victoryPulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.08); filter: brightness(1.2); }
        }

        .excel-tip {
            position: absolute;
            color: rgba(112, 173, 71, 0.9);
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(112, 173, 71, 0.8);
            animation: tipPulse 2s ease-in-out infinite;
        }

        @keyframes tipPulse {
            0%, 100% { transform: scale(1); opacity: 0.9; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .timer-option {
            padding: 10px 20px;
            border: 2px solid #217346;
            background: rgba(33, 115, 70, 0.1);
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            color: #217346;
        }

        .timer-option.selected {
            background: rgba(33, 115, 70, 0.3);
            box-shadow: 0 0 15px rgba(33, 115, 70, 0.5);
            transform: scale(1.1);
        }

        .timer-option:hover {
            background: rgba(33, 115, 70, 0.2);
            box-shadow: 0 0 10px rgba(33, 115, 70, 0.3);
        }

        .boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
            z-index: 50;
            animation: warningFlash 0.5s ease-in-out infinite alternate;
        }

        @keyframes warningFlash {
            0% { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="ui">
            <div>
                <span>üìä Points: <span id="score">0</span></span>
                <span style="margin-left: 20px;">üìà Lives: <span id="lives">3</span></span>
            </div>
            <div>
                <span>‚è∞ Time: <span id="timer">5:00</span></span>
                <span style="margin-left: 20px;">üìã Errors: <span id="enemies">0</span></span>
            </div>
        </div>

        <div id="startScreen">
            <div class="excel-logo">üìä</div>
            <div class="title">EXCEL WARRIOR</div>
            <div class="subtitle">
                üèπ Formula Fighter Edition üèπ<br>
                Defend the spreadsheet from data corruption!<br>
                Face the ultimate boss: "Missing Closing Parenthesis"
            </div>
            
            <div style="margin: 30px 0; color: #70ad47; font-size: 18px;">
                <div style="margin-bottom: 15px;">Choose Your Spreadsheet Complexity:</div>
                <div id="timerOptions" style="display: flex; justify-content: center; gap: 40px;">
                    <div id="timer1" class="timer-option selected">BASIC (1 MIN)</div>
                    <div id="timer3" class="timer-option">ADVANCED (3 MIN)</div>
                    <div id="timer5" class="timer-option">EXPERT (5 MIN)</div>
                </div>
                <div style="margin-top: 10px; font-size: 14px; opacity: 0.7;">Use ‚Üê ‚Üí to select, SPACEBAR to confirm</div>
            </div>
            
            <div class="controls">
                ARROW KEYS - Navigate Your Cell üß≠<br>
                SPACEBAR - Fire Formula Corrections üéØ<br>
                ARROW + SPACEBAR - Diagonal Formula Shots üìê<br>
                <br>
                üí° <span style="color: #70ad47;">Collect Excel Functions for Power-ups!</span> üí°<br>
                <br>
                <span style="color: #217346;">Press SPACEBAR to Enter the Spreadsheet</span>
            </div>
        </div>

        <div id="gameOverScreen">
            <div class="title">SPREADSHEET CORRUPTED</div>
            <div class="subtitle">Final Score: <span id="finalScore">0</span><br>üíæ Don't forget to save your work next time! üíæ</div>
            <div class="controls">Press SPACEBAR to Restart Excel</div>
        </div>

        <div id="victoryScreen">
            <div class="victory-title">üèÜ EXCEL MASTER üèÜ</div>
            <div class="subtitle">You have mastered the spreadsheet!<br>Final Score: <span id="victoryScore">0</span><br><br>üéâ All formulas debugged and parentheses balanced! üéâ<br>You are now a certified Excel Warrior!</div>
            <div class="controls">Press SPACEBAR to Return to Main Menu</div>
        </div>
    </div>

    <script>
        // Excel Warrior Game - Enhanced for Excel theme
        let game = {
            // Canvas and context
            canvas: null,
            ctx: null,
            width: 800,
            height: 600,
            
            // Game state
            gameState: 'start',
            score: 0,
            lives: 3,
            gameTime: 0,
            maxGameTime: 60,
            selectedTime: 1,
            backgroundTransition: 0,
            bossSpawned: false,
            boss: null,
            lightningFlashes: [],
            timerStopped: false,
            bossWarning: false,
            
            // Game objects
            player: null,
            formulaShots: [],
            excelErrors: [],
            particles: [],
            powerups: [],
            spreadsheetCells: [],
            gridLines: [],
            
            // Input and timing
            keys: {},
            lastShot: 0,
            messageTimer: 0,
            errorSpawnTimer: 0,
            powerupSpawnTimer: 0,
            lastTime: 0,
            
            // Excel-themed data
            excelErrors_list: [
                '#VALUE!', '#REF!', '#DIV/0!', '#NAME?', '#N/A', '#NULL!',
                'Circular Ref', 'Parse Error', 'Type Mismatch', 'Invalid Cell',
                'Formula Error', 'Syntax Error', 'Range Error', 'Data Error',
                'Missing Data', 'Wrong Format', 'Bad Reference', 'Overflow'
            ],
            
            excelFunctions: [
                'SUM', 'VLOOKUP', 'IF', 'COUNT', 'AVERAGE', 'MAX',
                'MIN', 'CONCATENATE', 'INDEX', 'MATCH', 'PIVOT',
                'FILTER', 'SORT', 'UNIQUE', 'XLOOKUP', 'SUMIF'
            ],
            
            excelTips: [
                "üí° Ctrl+Z is your best friend",
                "üìä Always validate your data sources",
                "üîç Use F2 to edit formulas in-cell",
                "üíæ Save early, save often",
                "üìã Name your ranges for clarity",
                "üéØ Use absolute references ($A$1)",
                "üìà Conditional formatting saves time",
                "‚å®Ô∏è Learn keyboard shortcuts"
            ],

            init: function() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.initializeSpreadsheet();
                this.setupEventListeners();
                this.createPlayer();
                this.updateTimerDisplay();
                this.gameLoop();
            },

            initializeSpreadsheet: function() {
                // Create spreadsheet grid background
                for (let i = 0; i < 20; i++) {
                    for (let j = 0; j < 15; j++) {
                        this.spreadsheetCells.push({
                            x: i * 40,
                            y: j * 40,
                            width: 40,
                            height: 40,
                            hasData: Math.random() < 0.3,
                            value: Math.random() < 0.5 ? Math.floor(Math.random() * 100) : 'A' + Math.floor(Math.random() * 26),
                            pulse: Math.random() * Math.PI * 2,
                            pulseSpeed: Math.random() * 0.02 + 0.01
                        });
                    }
                }
            },

            setupEventListeners: function() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    if (e.code === 'Space') {
                        e.preventDefault();
                        if (this.gameState === 'start') {
                            this.startGame();
                        } else if (this.gameState === 'gameOver') {
                            this.restartGame();
                        } else if (this.gameState === 'victory') {
                            this.restartGame();
                        } else if (this.gameState === 'playing') {
                            this.createFormulaShot();
                        }
                    }
                    
                    if (this.gameState === 'start') {
                        if (e.code === 'ArrowLeft') {
                            e.preventDefault();
                            this.selectPreviousTimer();
                        } else if (e.code === 'ArrowRight') {
                            e.preventDefault();
                            this.selectNextTimer();
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            },

            selectPreviousTimer: function() {
                const timers = [1, 3, 5];
                const currentIndex = timers.indexOf(this.selectedTime);
                const newIndex = currentIndex > 0 ? currentIndex - 1 : timers.length - 1;
                this.selectedTime = timers[newIndex];
                this.maxGameTime = this.selectedTime * 60;
                this.updateTimerDisplay();
            },

            selectNextTimer: function() {
                const timers = [1, 3, 5];
                const currentIndex = timers.indexOf(this.selectedTime);
                const newIndex = currentIndex < timers.length - 1 ? currentIndex + 1 : 0;
                this.selectedTime = timers[newIndex];
                this.maxGameTime = this.selectedTime * 60;
                this.updateTimerDisplay();
            },

            updateTimerDisplay: function() {
                document.getElementById('timer1').classList.remove('selected');
                document.getElementById('timer3').classList.remove('selected');
                document.getElementById('timer5').classList.remove('selected');
                document.getElementById('timer' + this.selectedTime).classList.add('selected');
            },

            createPlayer: function() {
                this.player = {
                    x: this.width / 2,
                    y: this.height - 60,
                    width: 24,
                    height: 24,
                    speed: 250,
                    baseSpeed: 250,
                    shotSize: 4,
                    baseShotSize: 4,
                    speedBoostTime: 0,
                    shotBoostTime: 0,
                    facing: 'up',
                    powerupMessage: '',
                    powerupMessageTime: 0,
                    invulnerable: 0
                };
            },

            startGame: function() {
                this.gameState = 'playing';
                this.score = 0;
                this.lives = 3;
                this.gameTime = 0;
                this.maxGameTime = this.selectedTime * 60;
                this.backgroundTransition = 0;
                this.bossSpawned = false;
                this.boss = null;
                this.timerStopped = false;
                this.bossWarning = false;
                this.formulaShots = [];
                this.excelErrors = [];
                this.particles = [];
                this.powerups = [];
                this.errorSpawnTimer = 0;
                this.powerupSpawnTimer = 0;
                this.createPlayer();
                
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('victoryScreen').style.display = 'none';
            },

            restartGame: function() {
                this.gameState = 'start';
                document.getElementById('startScreen').style.display = 'flex';
                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('victoryScreen').style.display = 'none';
            },

            victory: function() {
                this.gameState = 'victory';
                document.getElementById('victoryScore').textContent = this.score;
                document.getElementById('victoryScreen').style.display = 'flex';
                
                this.excelErrors = [];
                this.formulaShots = [];
                this.lightningFlashes = [];
                if (this.boss) this.boss.health = 0;
            },

            gameOver: function() {
                this.gameState = 'gameOver';
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOverScreen').style.display = 'flex';
            },

            update: function(deltaTime) {
                if (this.gameState !== 'playing') return;

                if (!this.timerStopped) {
                    this.gameTime += deltaTime;
                    this.backgroundTransition = Math.min(this.gameTime / this.maxGameTime, 1);
                }
                
                // Boss warning at 70% and spawn at 75%
                const bossWarningTime = this.maxGameTime * 0.7;
                const bossSpawnTime = this.maxGameTime * 0.75;
                
                if (this.gameTime >= bossWarningTime && !this.bossWarning && !this.bossSpawned) {
                    this.showBossWarning();
                }
                
                if (this.gameTime >= bossSpawnTime && !this.bossSpawned) {
                    this.spawnBoss();
                    this.bossSpawned = true;
                    this.timerStopped = true;
                }
                
                if (this.bossSpawned && this.boss && this.boss.health <= 0) {
                    this.victory();
                    return;
                }

                this.updatePlayer(deltaTime);
                this.updateFormulaShots(deltaTime);
                this.updateExcelErrors(deltaTime);
                this.updatePowerups(deltaTime);
                this.updateParticles(deltaTime);
                this.updateSpreadsheet(deltaTime);
                this.updateBoss(deltaTime);
                this.updateLightning(deltaTime);
                this.checkCollisions();
                this.updateUI();
                
                if (!this.boss || this.boss.health <= 0) {
                    this.errorSpawnTimer += deltaTime;
                    const spawnRate = Math.max(2.5 - (this.gameTime / 60), 1.0);
                    if (this.errorSpawnTimer > spawnRate) {
                        this.spawnExcelError();
                        this.errorSpawnTimer = 0;
                    }
                }
                
                this.powerupSpawnTimer += deltaTime;
                if (this.powerupSpawnTimer > 12 + Math.random() * 8) {
                    this.spawnPowerup();
                    this.powerupSpawnTimer = 0;
                }
                
                this.messageTimer += deltaTime;
                if (this.messageTimer > 8 + Math.random() * 4) {
                    this.showExcelTip();
                    this.messageTimer = 0;
                }
            },

            showBossWarning: function() {
                this.bossWarning = true;
                const warningDiv = document.createElement('div');
                warningDiv.className = 'boss-warning';
                warningDiv.innerHTML = '‚ö†Ô∏è CRITICAL ERROR DETECTED ‚ö†Ô∏è<br>Missing Closing Parenthesis Approaching!';
                document.getElementById('gameContainer').appendChild(warningDiv);
                
                setTimeout(() => {
                    if (warningDiv.parentNode) {
                        warningDiv.parentNode.removeChild(warningDiv);
                    }
                }, 3000);
            },

            updatePlayer: function(deltaTime) {
                if (this.player.invulnerable > 0) {
                    this.player.invulnerable -= deltaTime;
                }
                
                if (this.player.speedBoostTime > 0) {
                    this.player.speedBoostTime -= deltaTime;
                    if (this.player.speedBoostTime <= 0) {
                        this.player.speed = this.player.baseSpeed;
                    }
                }
                
                if (this.player.shotBoostTime > 0) {
                    this.player.shotBoostTime -= deltaTime;
                    if (this.player.shotBoostTime <= 0) {
                        this.player.shotSize = this.player.baseShotSize;
                    }
                }
                
                if (this.player.powerupMessageTime > 0) {
                    this.player.powerupMessageTime -= deltaTime;
                    if (this.player.powerupMessageTime <= 0) {
                        this.player.powerupMessage = '';
                    }
                }
                
                // Movement
                if (this.keys['ArrowLeft'] && this.player.x > 10) {
                    this.player.x -= this.player.speed * deltaTime;
                    this.player.facing = 'left';
                }
                if (this.keys['ArrowRight'] && this.player.x < this.width - this.player.width - 10) {
                    this.player.x += this.player.speed * deltaTime;
                    this.player.facing = 'right';
                }
                if (this.keys['ArrowUp'] && this.player.y > 10) {
                    this.player.y -= this.player.speed * deltaTime;
                    this.player.facing = 'up';
                }
                if (this.keys['ArrowDown'] && this.player.y < this.height - this.player.height - 10) {
                    this.player.y += this.player.speed * deltaTime;
                    this.player.facing = 'down';
                }

                if (this.keys['Space'] && Date.now() - this.lastShot > 150) {
                    this.createFormulaShot();
                    this.lastShot = Date.now();
                }
            },

            createFormulaShot: function() {
                let angle = 0;
                
                if (this.keys['ArrowUp'] && this.keys['ArrowRight']) {
                    angle = -Math.PI / 4;
                } else if (this.keys['ArrowUp'] && this.keys['ArrowLeft']) {
                    angle = -3 * Math.PI / 4;
                } else if (this.keys['ArrowDown'] && this.keys['ArrowRight']) {
                    angle = Math.PI / 4;
                } else if (this.keys['ArrowDown'] && this.keys['ArrowLeft']) {
                    angle = 3 * Math.PI / 4;
                } else if (this.keys['ArrowUp']) {
                    angle = -Math.PI / 2;
                } else if (this.keys['ArrowDown']) {
                    angle = Math.PI / 2;
                } else if (this.keys['ArrowLeft']) {
                    angle = Math.PI;
                } else if (this.keys['ArrowRight']) {
                    angle = 0;
                } else {
                    switch(this.player.facing) {
                        case 'up': angle = -Math.PI / 2; break;
                        case 'down': angle = Math.PI / 2; break;
                        case 'left': angle = Math.PI; break;
                        case 'right': angle = 0; break;
                    }
                }
                
                this.formulaShots.push({
                    x: this.player.x + this.player.width / 2,
                    y: this.player.y + this.player.height / 2,
                    vx: Math.cos(angle) * 450,
                    vy: Math.sin(angle) * 450,
                    width: this.player.shotSize,
                    height: this.player.shotSize,
                    life: 3,
                    maxLife: 3,
                    formula: '=' // Excel formula symbol
                });

                // Add shot particles
                for (let i = 0; i < 3; i++) {
                    this.particles.push({
                        x: this.player.x + this.player.width / 2,
                        y: this.player.y + this.player.height / 2,
                        vx: Math.cos(angle) * 80 + (Math.random() - 0.5) * 30,
                        vy: Math.sin(angle) * 80 + (Math.random() - 0.5) * 30,
                        life: 0.3,
                        maxLife: 0.3,
                        size: Math.random() * 2 + 1,
                        color: [33, 115, 70]
                    });
                }
            },

            spawnExcelError: function() {
                const error = this.excelErrors_list[Math.floor(Math.random() * this.excelErrors_list.length)];
                const edge = Math.floor(Math.random() * 4);
                let x, y, vx, vy;
                
                switch (edge) {
                    case 0: // Top
                        x = Math.random() * this.width;
                        y = -30;
                        vx = (Math.random() - 0.5) * 40;
                        vy = Math.random() * 25 + 15;
                        break;
                    case 1: // Right
                        x = this.width + 30;
                        y = Math.random() * this.height;
                        vx = -(Math.random() * 25 + 15);
                        vy = (Math.random() - 0.5) * 40;
                        break;
                    case 2: // Bottom
                        x = Math.random() * this.width;
                        y = this.height + 30;
                        vx = (Math.random() - 0.5) * 40;
                        vy = -(Math.random() * 25 + 15);
                        break;
                    case 3: // Left
                        x = -30;
                        y = Math.random() * this.height;
                        vx = Math.random() * 25 + 15;
                        vy = (Math.random() - 0.5) * 40;
                        break;
                }
                
                const isCritical = Math.random() < 0.25; // 25% chance for critical errors
                const health = isCritical ? 3 : 1;
                
                this.excelErrors.push({
                    x: x, y: y, vx: vx, vy: vy,
                    error: error,
                    width: error.length * 10,
                    height: 20,
                    health: health,
                    maxHealth: health,
                    intensity: Math.random() * 0.5 + 0.5,
                    wobble: Math.random() * Math.PI * 2,
                    isCritical: isCritical
                });
            },

            spawnPowerup: function() {
                const func = this.excelFunctions[Math.floor(Math.random() * this.excelFunctions.length)];
                const edge = Math.floor(Math.random() * 4);
                let x, y, vx, vy;
                
                switch (edge) {
                    case 0: x = Math.random() * this.width; y = -30; vx = (Math.random() - 0.5) * 20; vy = Math.random() * 20 + 10; break;
                    case 1: x = this.width + 30; y = Math.random() * this.height; vx = -(Math.random() * 20 + 10); vy = (Math.random() - 0.5) * 20; break;
                    case 2: x = Math.random() * this.width; y = this.height + 30; vx = (Math.random() - 0.5) * 20; vy = -(Math.random() * 20 + 10); break;
                    case 3: x = -30; y = Math.random() * this.height; vx = Math.random() * 20 + 10; vy = (Math.random() - 0.5) * 20; break;
                }
                
                const powerupType = Math.random() < 0.5 ? 'speed' : 'shot';
                
                this.powerups.push({
                    x: x, y: y, vx: vx, vy: vy,
                    func: func, type: powerupType,
                    width: func.length * 12, height: 20,
                    pulse: Math.random() * Math.PI * 2
                });
            },

            showExcelTip: function() {
                const tip = this.excelTips[Math.floor(Math.random() * this.excelTips.length)];
                const tipDiv = document.createElement('div');
                tipDiv.className = 'excel-tip';
                tipDiv.textContent = tip;
                tipDiv.style.left = Math.random() * 600 + 100 + 'px';
                tipDiv.style.top = Math.random() * 400 + 100 + 'px';
                
                document.getElementById('gameContainer').appendChild(tipDiv);
                
                setTimeout(() => {
                    if (tipDiv.parentNode) {
                        tipDiv.parentNode.removeChild(tipDiv);
                    }
                }, 4000);
            },

            spawnBoss: function() {
                this.excelErrors = [];
                
                // Lightning effects for boss entrance
                for (let i = 0; i < 15; i++) {
                    this.lightningFlashes.push({
                        x: Math.random() * this.width,
                        y: Math.random() * this.height,
                        width: 4 + Math.random() * 6,
                        height: 60 + Math.random() * 120,
                        life: 0.8 + Math.random() * 0.7,
                        maxLife: 1.5,
                        intensity: Math.random() * 0.9 + 0.1
                    });
                }
                
                // Create the ultimate boss: Missing Closing Parenthesis
                this.boss = {
                    x: this.width / 2 - 80,
                    y: this.height / 4,
                    width: 160,
                    height: 100,
                    health: 100, // More health for ultimate boss
                    maxHealth: 100,
                    vx: 0,
                    vy: 0,
                    phase: 0,
                    attackTimer: 0,
                    pulsePhase: 0,
                    name: 'Missing Closing Parenthesis',
                    attackPattern: 0
                };
            },

            updateBoss: function(deltaTime) {
                if (!this.boss || this.boss.health <= 0) return;
                
                this.boss.phase += deltaTime;
                this.boss.pulsePhase += deltaTime * 4;
                this.boss.attackTimer += deltaTime;
                
                // Complex boss movement
                this.boss.x += Math.sin(this.boss.phase * 0.6) * 60 * deltaTime;
                this.boss.y += Math.cos(this.boss.phase * 0.4) * 20 * deltaTime;
                
                // Keep boss on screen
                this.boss.x = Math.max(30, Math.min(this.width - this.boss.width - 30, this.boss.x));
                this.boss.y = Math.max(30, Math.min(this.height / 2, this.boss.y));
                
                // Boss attacks with different patterns
                if (this.boss.attackTimer > 1.8) {
                    this.spawnBossAttack();
                    this.boss.attackTimer = 0;
                    this.boss.attackPattern = (this.boss.attackPattern + 1) % 3;
                }
            },

            spawnBossAttack: function() {
                const attacks = ['#ERROR!', 'SYNTAX', 'MISSING )', 'PARSE FAIL', 'BAD FORMULA'];
                
                switch(this.boss.attackPattern) {
                    case 0: // Spread attack
                        for (let i = 0; i < 5; i++) {
                            const angle = (i - 2) * 0.3;
                            const error = attacks[Math.floor(Math.random() * attacks.length)];
                            this.excelErrors.push({
                                x: this.boss.x + this.boss.width / 2,
                                y: this.boss.y + this.boss.height,
                                vx: Math.sin(angle) * 80,
                                vy: Math.cos(angle) * 80 + 50,
                                error: error,
                                width: error.length * 10,
                                height: 20,
                                health: 2,
                                maxHealth: 2,
                                intensity: 1,
                                wobble: Math.random() * Math.PI * 2,
                                isCritical: true
                            });
                        }
                        break;
                    case 1: // Circular attack
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const error = attacks[Math.floor(Math.random() * attacks.length)];
                            this.excelErrors.push({
                                x: this.boss.x + this.boss.width / 2,
                                y: this.boss.y + this.boss.height / 2,
                                vx: Math.cos(angle) * 100,
                                vy: Math.sin(angle) * 100,
                                error: error,
                                width: error.length * 10,
                                height: 20,
                                health: 2,
                                maxHealth: 2,
                                intensity: 1,
                                wobble: Math.random() * Math.PI * 2,
                                isCritical: true
                            });
                        }
                        break;
                    case 2: // Targeted attack
                        const dx = this.player.x - this.boss.x;
                        const dy = this.player.y - this.boss.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > 0) {
                            for (let i = 0; i < 3; i++) {
                                const error = 'MISSING )';
                                this.excelErrors.push({
                                    x: this.boss.x + this.boss.width / 2,
                                    y: this.boss.y + this.boss.height,
                                    vx: (dx / distance) * 120 + (Math.random() - 0.5) * 40,
                                    vy: (dy / distance) * 120 + (Math.random() - 0.5) * 40,
                                    error: error,
                                    width: error.length * 10,
                                    height: 20,
                                    health: 3,
                                    maxHealth: 3,
                                    intensity: 1,
                                    wobble: Math.random() * Math.PI * 2,
                                    isCritical: true
                                });
                            }
                        }
                        break;
                }
            },

            updateFormulaShots: function(deltaTime) {
                for (let i = this.formulaShots.length - 1; i >= 0; i--) {
                    const shot = this.formulaShots[i];
                    shot.x += shot.vx * deltaTime;
                    shot.y += shot.vy * deltaTime;
                    shot.life -= deltaTime;
                    
                    if (shot.life <= 0 || shot.x < 0 || shot.x > this.width || shot.y < 0 || shot.y > this.height) {
                        this.formulaShots.splice(i, 1);
                    }
                }
            },

            updateExcelErrors: function(deltaTime) {
                for (let i = this.excelErrors.length - 1; i >= 0; i--) {
                    const error = this.excelErrors[i];
                    
                    error.x += error.vx * deltaTime;
                    error.y += error.vy * deltaTime;
                    error.wobble += deltaTime * 3;
                    
                    // Move towards player slightly
                    const dx = this.player.x - error.x;
                    const dy = this.player.y - error.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const attraction = 8 * deltaTime;
                        error.vx += (dx / distance) * attraction;
                        error.vy += (dy / distance) * attraction;
                    }
                    
                    if (error.x < -200 || error.x > this.width + 200 || 
                        error.y < -200 || error.y > this.height + 200) {
                        this.excelErrors.splice(i, 1);
                    }
                }
            },

            updatePowerups: function(deltaTime) {
                for (let i = this.powerups.length - 1; i >= 0; i--) {
                    const powerup = this.powerups[i];
                    powerup.x += powerup.vx * deltaTime;
                    powerup.y += powerup.vy * deltaTime;
                    powerup.pulse += deltaTime * 4;
                    
                    if (powerup.x < -200 || powerup.x > this.width + 200 || 
                        powerup.y < -200 || powerup.y > this.height + 200) {
                        this.powerups.splice(i, 1);
                    }
                }
            },

            updateParticles: function(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx * deltaTime;
                    particle.y += particle.vy * deltaTime;
                    particle.life -= deltaTime;
                    particle.vy += 40 * deltaTime; // gravity
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            },

            updateSpreadsheet: function(deltaTime) {
                for (let cell of this.spreadsheetCells) {
                    cell.pulse += cell.pulseSpeed;
                }
            },

            updateLightning: function(deltaTime) {
                for (let i = this.lightningFlashes.length - 1; i >= 0; i--) {
                    const lightning = this.lightningFlashes[i];
                    lightning.life -= deltaTime;
                    
                    if (lightning.life <= 0) {
                        this.lightningFlashes.splice(i, 1);
                    }
                }
                
                if (this.boss && this.boss.health > 0 && Math.random() < 0.03) {
                    this.lightningFlashes.push({
                        x: Math.random() * this.width,
                        y: 0,
                        width: 3 + Math.random() * 4,
                        height: this.height,
                        life: 0.15 + Math.random() * 0.25,
                        maxLife: 0.4,
                        intensity: 0.7 + Math.random() * 0.3
                    });
                }
            },

            checkCollisions: function() {
                // Formula shots vs errors
                for (let i = this.formulaShots.length - 1; i >= 0; i--) {
                    const shot = this.formulaShots[i];
                    for (let j = this.excelErrors.length - 1; j >= 0; j--) {
                        const error = this.excelErrors[j];
                        if (this.isColliding(shot, error)) {
                            error.health -= 1;
                            this.formulaShots.splice(i, 1);
                            
                            if (error.health <= 0) {
                                this.createFixEffect(error.x + error.width / 2, error.y + error.height / 2);
                                this.excelErrors.splice(j, 1);
                                this.score += error.isCritical ? 200 : 75;
                            } else {
                                this.createHitEffect(error.x + error.width / 2, error.y + error.height / 2);
                                this.score += 25;
                            }
                            break;
                        }
                    }
                    
                    // Shots vs boss
                    if (this.boss && this.boss.health > 0 && this.isColliding(shot, this.boss)) {
                        this.boss.health -= 2; // Boss takes less damage per shot
                        this.formulaShots.splice(i, 1);
                        this.score += 50;
                        
                        if (this.boss.health <= 0) {
                            this.createBossDestroyEffect();
                            this.score += 2000;
                        } else {
                            this.createHitEffect(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2);
                        }
                        break;
                    }
                }

                // Player vs errors
                for (let i = this.excelErrors.length - 1; i >= 0; i--) {
                    const error = this.excelErrors[i];
                    if (this.player.invulnerable <= 0 && this.isColliding(this.player, error)) {
                        this.createCorruptionEffect(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2);
                        this.lives--;
                        this.player.invulnerable = 2.5;
                        this.excelErrors.splice(i, 1);
                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                        break;
                    }
                }

                // Player vs boss
                if (this.boss && this.boss.health > 0 && this.player.invulnerable <= 0 && this.isColliding(this.player, this.boss)) {
                    this.createCorruptionEffect(this.player.x + this.player.width / 2, this.player.y + this.player.height / 2);
                    this.lives -= 2;
                    this.player.invulnerable = 2.5;
                    if (this.lives <= 0) {
                        this.gameOver();
                    }
                }

                // Player vs powerups
                for (let i = this.powerups.length - 1; i >= 0; i--) {
                    const powerup = this.powerups[i];
                    if (this.isColliding(this.player, powerup)) {
                        this.applyPowerup(powerup);
                        this.createPowerupEffect(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2);
                        this.powerups.splice(i, 1);
                        this.score += 150;
                        break;
                    }
                }
            },

            isColliding: function(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            },

            applyPowerup: function(powerup) {
                if (powerup.type === 'speed') {
                    this.player.speed = this.player.baseSpeed * 1.8;
                    this.player.speedBoostTime = 12;
                    this.player.powerupMessage = 'üöÄ ' + powerup.func + ' Speed!';
                    this.player.powerupMessageTime = 3;
                } else if (powerup.type === 'shot') {
                    this.player.shotSize = this.player.baseShotSize * 2.5;
                    this.player.shotBoostTime = 15;
                    this.player.powerupMessage = 'üìä ' + powerup.func + ' Power!';
                    this.player.powerupMessageTime = 3;
                }
            },

            createPowerupEffect: function(x, y) {
                for (let i = 0; i < 25; i++) {
                    const angle = (i / 25) * Math.PI * 2;
                    const speed = Math.random() * 220 + 120;
                    this.particles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: Math.random() * 1.8 + 1,
                        maxLife: Math.random() * 1.8 + 1,
                        size: Math.random() * 6 + 4,
                        color: [112, 173, 71]
                    });
                }
            },

            createFixEffect: function(x, y) {
                for (let i = 0; i < 18; i++) {
                    const angle = (i / 18) * Math.PI * 2;
                    const speed = Math.random() * 180 + 80;
                    this.particles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: Math.random() * 1.2 + 0.8,
                        maxLife: Math.random() * 1.2 + 0.8,
                        size: Math.random() * 5 + 3,
                        color: [33, 115, 70]
                    });
                }
            },

            createCorruptionEffect: function(x, y) {
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const speed = Math.random() * 120 + 50;
                    this.particles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: Math.random() * 1 + 0.5,
                        maxLife: Math.random() * 1 + 0.5,
                        size: Math.random() * 4 + 2,
                        color: [255, 120, 120]
                    });
                }
            },

            createBossDestroyEffect: function() {
                for (let i = 0; i < 80; i++) {
                    this.particles.push({
                        x: this.boss.x + this.boss.width / 2,
                        y: this.boss.y + this.boss.height / 2,
                        vx: (Math.random() - 0.5) * 600,
                        vy: (Math.random() - 0.5) * 600,
                        life: 3.0,
                        maxLife: 3.0,
                        size: Math.random() * 16 + 8,
                        color: [255, 215, 0],
                        type: 'explosion'
                    });
                }
                
                this.excelErrors = [];
            },

            createHitEffect: function(x, y) {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 180,
                        vy: (Math.random() - 0.5) * 180,
                        life: 0.5,
                        maxLife: 0.5,
                        size: Math.random() * 5 + 3,
                        color: [255, 255, 120],
                        type: 'hit'
                    });
                }
            },

            updateUI: function() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                
                if (this.timerStopped && this.boss && this.boss.health > 0) {
                    document.getElementById('timer').textContent = 'BOSS FIGHT!';
                } else {
                    const timeLeft = Math.max(0, this.maxGameTime - this.gameTime);
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = Math.floor(timeLeft % 60);
                    document.getElementById('timer').textContent = minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
                }
                
                document.getElementById('enemies').textContent = this.excelErrors.length;
            },

            gameLoop: function() {
                const currentTime = Date.now();
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;

                this.update(deltaTime);
                this.render();

                requestAnimationFrame(() => this.gameLoop());
            },

            render: function() {
                this.ctx.fillStyle = 'rgba(7, 16, 9, 0.15)';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.drawSpreadsheet();

                if (this.gameState !== 'playing') return;

                this.drawPlayer();
                
                for (let shot of this.formulaShots) {
                    this.drawFormulaShot(shot);
                }
                
                for (let error of this.excelErrors) {
                    this.drawExcelError(error);
                }
                
                for (let powerup of this.powerups) {
                    this.drawPowerup(powerup);
                }
                
                for (let particle of this.particles) {
                    this.drawParticle(particle);
                }
                
                for (let lightning of this.lightningFlashes) {
                    this.drawLightning(lightning);
                }
                
                if (this.boss && this.boss.health > 0) {
                    this.drawBoss();
                }
            },

            drawSpreadsheet: function() {
                this.ctx.globalAlpha = 0.1;
                
                // Draw spreadsheet cells
                for (let cell of this.spreadsheetCells) {
                    if (cell.hasData) {
                        const pulse = Math.sin(cell.pulse) * 0.3 + 0.7;
                        this.ctx.globalAlpha = 0.05 * pulse;
                        this.ctx.strokeStyle = '#217346';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(cell.x, cell.y, cell.width, cell.height);
                        
                        this.ctx.fillStyle = '#217346';
                        this.ctx.font = '8px Courier New';
                        this.ctx.fillText(cell.value.toString().substring(0, 3), cell.x + 2, cell.y + 12);
                    }
                }
                
                this.ctx.globalAlpha = 1;
            },

            drawPlayer: function() {
                const player = this.player;
                
                this.ctx.shadowColor = '#217346';
                this.ctx.shadowBlur = player.invulnerable > 0 ? 25 : 12;
                
                // Draw Excel icon as player
                this.ctx.fillStyle = player.invulnerable > 0 ? '#ffffff' : '#217346';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('üìä', player.x + player.width / 2, player.y + player.height - 2);
                
                this.ctx.shadowBlur = 0;
                
                // Draw powerup message
                if (player.powerupMessage && player.powerupMessageTime > 0) {
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillStyle = '#70ad47';
                    this.ctx.shadowColor = '#70ad47';
                    this.ctx.shadowBlur = 10;
                    
                    const bobOffset = Math.sin(Date.now() * 0.006) * 4;
                    const alpha = Math.min(player.powerupMessageTime / 0.7, 1);
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillText(
                        player.powerupMessage,
                        player.x + player.width / 2,
                        player.y - 12 + bobOffset
                    );
                    this.ctx.globalAlpha = 1;
                    this.ctx.shadowBlur = 0;
                }
            },

            drawFormulaShot: function(shot) {
                const alpha = shot.life / shot.maxLife;
                this.ctx.globalAlpha = alpha;
                this.ctx.fillStyle = '#217346';
                this.ctx.shadowColor = '#217346';
                this.ctx.shadowBlur = 12;
                
                // Draw formula symbol
                this.ctx.font = 'bold 12px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(shot.formula, shot.x, shot.y);
                
                this.ctx.shadowBlur = 0;
                this.ctx.globalAlpha = 1;
            },

            drawExcelError: function(error) {
                const isStrong = error.health > 1;
                this.ctx.fillStyle = isStrong ? '#cc0000' : '#ff6666';
                this.ctx.font = isStrong ? 'bold 14px Courier New' : '12px Courier New';
                this.ctx.textAlign = 'center';
                
                const wobbleOffset = Math.sin(error.wobble) * 2;
                const alpha = error.intensity;
                
                this.ctx.globalAlpha = alpha;
                this.ctx.shadowColor = isStrong ? '#cc0000' : '#ff6666';
                this.ctx.shadowBlur = isStrong ? 15 : 8;
                
                if (isStrong) {
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeText(
                        error.error,
                        error.x + error.width / 2,
                        error.y + error.height / 2 + wobbleOffset
                    );
                }
                
                this.ctx.fillText(
                    error.error,
                    error.x + error.width / 2,
                    error.y + error.height / 2 + wobbleOffset
                );
                
                this.ctx.shadowBlur = 0;
                this.ctx.globalAlpha = 1;
            },

            drawPowerup: function(powerup) {
                const pulse = Math.sin(powerup.pulse) * 0.4 + 0.8;
                this.ctx.fillStyle = '#70ad47';
                this.ctx.font = 'bold 12px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.globalAlpha = pulse;
                this.ctx.shadowColor = '#70ad47';
                this.ctx.shadowBlur = 15;
                
                this.ctx.fillText(
                    powerup.func,
                    powerup.x + powerup.width / 2,
                    powerup.y + powerup.height / 2
                );
                
                // Draw icon
                this.ctx.font = '10px Arial';
                const icon = powerup.type === 'speed' ? 'üöÄ' : 'üìä';
                this.ctx.fillText(
                    icon,
                    powerup.x + powerup.width / 2,
                    powerup.y - 8
                );
                
                this.ctx.shadowBlur = 0;
                this.ctx.globalAlpha = 1;
            },

            drawParticle: function(particle) {
                const alpha = particle.life / particle.maxLife;
                const r = particle.color[0];
                const g = particle.color[1];
                const b = particle.color[2];
                
                this.ctx.fillStyle = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                this.ctx.fill();
            },

            drawBoss: function() {
                if (!this.boss || this.boss.health <= 0) return;
                
                const pulse = Math.sin(this.boss.pulsePhase) * 0.3 + 0.7;
                const healthRatio = this.boss.health / this.boss.maxHealth;
                
                // Boss body - menacing parenthesis
                this.ctx.fillStyle = `rgba(139, 0, 0, ${pulse})`;
                this.ctx.shadowColor = '#8b0000';
                this.ctx.shadowBlur = 25;
                
                // Draw giant opening parenthesis
                this.ctx.font = 'bold 80px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('(', this.boss.x + 40, this.boss.y + 60);
                
                // Draw menacing "missing closing parenthesis" text
                this.ctx.font = 'bold 12px Courier New';
                this.ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                this.ctx.fillText('MISSING )', this.boss.x + this.boss.width / 2, this.boss.y + 85);
                
                // Draw boss name
                this.ctx.font = 'bold 10px Arial';
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillText(this.boss.name, this.boss.x + this.boss.width / 2, this.boss.y - 10);
                
                // Health bar
                const barWidth = this.boss.width;
                const barHeight = 8;
                const barX = this.boss.x;
                const barY = this.boss.y - 25;
                
                this.ctx.fillStyle = 'rgba(100, 0, 0, 0.8)';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.9)';
                this.ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
                
                this.ctx.shadowBlur = 0;
            },

            drawLightning: function(lightning) {
                const alpha = lightning.life / lightning.maxLife;
                this.ctx.globalAlpha = alpha * lightning.intensity;
                this.ctx.fillStyle = '#ffffff';
                this.ctx.shadowColor = '#ffffff';
                this.ctx.shadowBlur = 15;
                
                this.ctx.fillRect(lightning.x, lightning.y, lightning.width, lightning.height);
                
                if (Math.random() < 0.4) {
                    this.ctx.fillRect(lightning.x - 3, lightning.y, lightning.width + 6, lightning.height);
                }
                
                this.ctx.shadowBlur = 0;
                this.ctx.globalAlpha = 1;
            }
        };

        // Initialize the game
        window.addEventListener('DOMContentLoaded', () => {
            game.init();
        });
    </script>
</body>
</html>
